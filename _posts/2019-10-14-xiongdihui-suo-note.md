---
layout: post
title:  "数据库中锁的概念"
date:   2019-10-14
categories: Database
tags: note
---

* content
{:toc}

数据库中锁的概念









# 锁的概念
### 锁是什么
1. 数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。
2. 加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作

### 锁的分类
1. 共享(S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。 
2. 排它(X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。 

#### 例子1：
1. T1:UPDATE myemp set ename=’hello’ where empno=7369;(表级共享锁+行级排他锁)
2. T2:ALTER TABLE myemp MODIFY(empno NUMBER(7));(表级排他锁)
3. 结果：T2在执行update前，试图对table表加一个排他锁，而数据库规定同一资源上不能同时共存共享锁和排他锁。所以T2必须等T1执行完，释放了共享锁，才能加上排他锁，然后才能开始执行update语句

#### 例子2：
1. T1:update myemp set ename='hello' where empno=7788; (表级共享锁)
2. T1:update myemp set ename='hello' where empno=7369; (表级共享锁)
3. 结果：两个锁是可以同时存在于同一资源上的（比如同一个表上）。这被称为共享锁与共享锁兼容。

#### 例子3：
1. T1:update myemp set ename='hello' where empno=7788; (表级共享锁)
2. T2:update myemp set ename='hello' where empno=7788; (表级共享锁)
3. T3:ALTER TABLE myemp MODIFY(empno NUMBER(7));(表级排他锁)
4. 结果：T2不用等T1运行完就能运行，T3却要等T1和T2都运行完才能运行。因为T3必须等T1和T2的共享锁全部释放才能进行加排他锁然后执行操作。

#### 例子4
1. T1:    update myemp set ename='hello' where empno=7788;(行级排他锁)
2. T2:    update myemp set ename='hello' where empno=7788;(行级排他锁)
3. 结果：T2必须要等T1运行完成之后，才会被运行，因为此时表被T1的行级排他锁给锁住。

# 并发控制机制
在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是著名的并发性问题。

### 悲观锁
1. 悲观锁：悲观锁顾名思义，就是对数据的冲突采取一种悲观的态度，也就是说假设数据肯定会冲突，所以在数据开始读取的时候就把数据锁定住。Oracle的悲观锁需要利用一条现有的连接，分成两种方式，从SQL语句的区别来看，就是一种是for update，一种是for update nowait的形式。

#### 例子1
1. `select * from myemp where empno=7369 for update；`，这时只能查看，不能对锁定的数据进行锁定、更改和删除操作。如果输入：`select * from myemp where empno=7369 for update nowait；`

### 乐观锁
1. 而乐观锁就是认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让用户返回错误的信息，让用户决定如何去做。在乐观锁中，我们有3种常用的做法来实现：
    1. 第一种就是在数据取得的时候把整个数据都copy到应用中，在进行提交的时候比对当前数据库中的数据和开始的时候更新前取得的数据。当发现两个数据一模一样以后，就表示没有冲突可以提交，否则则是并发冲突，需要去用业务逻辑进行解决。
    2. 第二种乐观锁的做法就是采用版本戳。采用版本戳的话，首先需要在你有乐观锁的数据库table上建立一个新的column，比如为number型，当你数据每更新一次的时候，版本数就会往上增加1。比如同样有2个session同样对某条数据进行操作。两者都取到当前的数据的版本号为1，当第一个session进行数据更新后，在提交的时候查看到当前数据的版本还为1，和自己一开始取到的版本相同。就正式提交，然后把版本号增加1，这个时候当前数据的版本为2。
    3. 第三种乐观锁的做法就是采用时间戳，同版本戳，最后比较时间。













